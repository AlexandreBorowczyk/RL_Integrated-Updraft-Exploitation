import numpy as np

class params_rl:
    def __init__(self):
        self.N_EPOCH            = 10e3             # total number of episodes to be evaluated
        self.N_EPPERITER        = 25               # number of episodes to be evaluated within a policy update
        self.LEARNING_RATE      = 1e-4
        self.GAMMA              = 1
        self.LAMBDA             = 0.96
        self.EPS_CLIP           = 0.2
        self.N_UPDATE           = 3                 # number of policy updates for batch of I_EPOCH episodes
        self.SIGMA              = .2                # std-deviation for exploration (0.1 -> 0.6 deg after scaling)
        self.AUTO_EXPLORATION   = True              # exploration driven by NN output (self.SIGMA obsolete if true)
        self.SEED               = None              # manual specification of random seed (Fabian: 42)

class params_model:
    def __init__(self):
        self.DIM_IN         = 7                     # dimension of observation-space (time + state + wind) TODO: 10 including wind
        self.DIM_OUT        = 2                     # dimension of action-space
        self.DIM_HIDDEN     = 64
        self.NUM_HIDDEN     = 2

class params_task:
    def __init__(self):
        # triangle orientation: alpha - pi/2 ('alpha' referred to in GPS triangle regulatioself.TRIANGLEn code)
        self.ORIENTATION    = 0
        # transformation matrix from triangle-coordinates to local NE-coordinates
        self.ROTATION       = np.transpose(np.array([[np.cos(self.ORIENTATION), np.sin(self.ORIENTATION)],
                                                     [-np.sin(self.ORIENTATION), np.cos(self.ORIENTATION)]]))
        # local NE-coordinates of the triangle vertices (2 x 3)
        self.TRIANGLE       = np.matmul(self.ROTATION, np.array([[0., 350, 0.],
                                                                 [350, 0., -350]]))
        # task (alternatives: 'distance', 'speed')
        self.TASK           = 'distance'
        # working time to have the task done (relevant for 'distance' only)
        self.WORKING_TIME   = 60*30

        # initialization method (alternatives: 'fix', 'random_normal')
        self.INIT_METHOD    = 'fix'
        # initial state value
        self.INITIAL_STATE  = np.append(np.array([0., 0., -400.]),
                                        np.append(np.matmul(self.ROTATION, np.array([[0.], [15.]])), 1))
        # std-dev. for init method: random_normal
        self.INITIAL_STD    = np.append(np.append(np.matmul(self.ROTATION, np.array([[20.], [0.]])), 20.),
                                        np.array([2., 2., .5]))

        # bank angle and AoA constraint to [MIN MAX]   (deg)
        self.ACTION_SPACE   = np.array([[0, 12],
                                        [-90, 90]])

        # mean values for observation standardization (xy shifted into triangle center)
        self.OBS_MEAN       =  np.append(np.append(np.append(self.WORKING_TIME/2,
                                                             self.TRIANGLE[:, 1]/2), self.INITIAL_STATE[2]/2),
                                         np.array([15., 15., 1.]))
        # std-deviation values for observation standardization
        self.OBS_STD        = np.array([self.WORKING_TIME/2,
                                        500, 500, abs(self.INITIAL_STATE[2])/2,
                                        5., 5., 2.])

class params_sim:
    def __init__(self):
        self.TIMESTEP       = 0.2                   # const. u simulation time-step (s)
        self.USE_RK45       = True                  # Runge-Kutta 45 integration, False -> Euler forward


class params_glider:
    def __init__(self):
        self.M              = 3.366                 # aircraft mass                 (kg)
        self.S              = .568                  # reference area                (m2)
        self.ST             = 10.2                  # aspect ratio                  (-)
        self.OE             = .9                    # oswald factor                 (-)
        self.CD0            = .015                  # zero lift drag coefficient    (-)

class params_physics:
    def __init__(self):
        self.RHO            = 1.225                 # air density                   (kg/m3)
        self.G              = 9.81                  # gravitational acceleration    (m/s2)

class params_logging:
    def __init__(self):
        self.PRINT_INTERVAL = 100
        self.SAVE_INTERVAL  = 1e3