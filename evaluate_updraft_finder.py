import gym
import glider
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.distributions import normal
from torch.distributions import Categorical
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib import cm

import datetime
import os
import sys
import warnings

from parameters import params_triangle_soaring, params_environment

def main(env, controller, n_iter, params_agent, validation_mask=False):
    state = env.reset()
    obs = env.get_observation()
    lstm_hidden_in = controller.model.reset_lstm()
    done = False
    ret = 0

    pos_list = [[state[0], state[1], state[2]]]
    ctrl_list = []
    updraft_position_init = np.copy(env._wind_fun._wind_data['updraft_position'])

    # set params
    _params_task    = params_triangle_soaring.params_task()
    _params_sim     = params_environment.params_sim()
    _params_wind    = params_environment.params_wind()

    # actual rollout
    while not done:

        # run policy
        action, _, _, lstm_hidden_out = controller.select_action(torch.FloatTensor(obs), lstm_hidden_in,
                                                                 validation_mask=validation_mask)
        obs, r, done, info = env.step(np.array([[action.item(), 1]]))
        ret += r
        lstm_hidden_in = lstm_hidden_out

        # write to lists
        pos_list.append([env.state[0], env.state[1], env.state[2]])
        control = env.action2control(np.array([action.detach().cpu().flatten(), 1]))
        ctrl_list.append([control[0], control[1]])

    time = env.time

    # setup plot
    fig = plt.figure()
    fig.set_size_inches(11.69, 8.27)  # DinA4
    fig.suptitle("Sample after {} iterations of training:\nReturn: {:.1f}, Wind: {:.1f} m/s from {:.1f}Â°"
                 .format(n_iter, ret, env._wind_fun._wind_data['headwind_velocity'],
                         np.rad2deg(env._wind_fun._wind_data['headwind_direction'])))

    grid = gridspec.GridSpec(ncols=2, nrows=3, figure=fig)
    ax1 = fig.add_subplot(grid[0:2, 0])
    ax2 = fig.add_subplot(grid[-1, :])
    ax3 = fig.add_subplot(grid[0, 1])
    ax4 = fig.add_subplot(grid[1, 1])

    # plot updraft position trajectory
    updraft_position_final = env._wind_fun._wind_data['updraft_position']
    if not (np.isnan(updraft_position_init).any() or np.isnan(updraft_position_final).any()):
        # ax1.plot(updraft_position_init[1, :], updraft_position_init[0, :], 'b+')
        # ax1.plot(updraft_position_final[1, :], updraft_position_final[0, :], 'r+')
        for k in range(len(updraft_position_init[0])):
            updraft_init_outline = plt.Circle((updraft_position_init[1, k], updraft_position_init[0, k]), _params_wind.DELTA,
                                         color='b', fill=False)
            updraft_final_outline = plt.Circle((updraft_position_final[1, k], updraft_position_final[0, k]),
                                              _params_wind.DELTA,
                                              color='r', fill=False)
            ax1.add_artist(updraft_init_outline)
            ax1.add_artist(updraft_final_outline)
            ax1.arrow(updraft_position_init[1, k], updraft_position_init[0, k],
                      (updraft_position_final[1, k]-updraft_position_init[1, k]),
                      (updraft_position_final[0, k]-updraft_position_init[0, k]), head_width=20)

    # plot solid north-east trajectory with color gradient
    timeVec = np.linspace(params_agent.TIMESTEP_CTRL, time, len(pos_list))
    colormap = cm.spring(timeVec / timeVec.max())

    for k in range(len(colormap)):
        x_segm = np.array(pos_list)[k:(k + 2), 1]
        y_segm = np.array(pos_list)[k:(k + 2), 0]
        c_segm = colormap[k]
        ax1.plot(x_segm, y_segm, c=c_segm)

    ax1.set_xlim(-params_agent.DISTANCE_MAX, params_agent.DISTANCE_MAX)
    ax1.set_ylim(-params_agent.DISTANCE_MAX, params_agent.DISTANCE_MAX)
    ax1.set_xlabel("east (m)")
    ax1.set_ylabel("north (m)")
    ax1.grid(True)

    # plot solid height trajectory with color gradient
    for k in range(len(colormap)):
        x_segm = timeVec[k:(k + 2)]
        y_segm = -np.array(pos_list)[k:(k + 2), 2]
        c_segm = colormap[k]
        ax2.plot(x_segm, y_segm, c=c_segm)

    ax2.set_xlim(0, params_agent.DURATION_MAX)
    ax2.set_ylim(0, params_agent.HEIGHT_MAX)
    ax2.set_xlabel("time (s)")
    ax2.set_ylabel("height (m)")
    ax2.grid(True)

    ax3.scatter(timeVec[1:], (180 / np.pi) * np.array(ctrl_list)[:, 0],  s=2, c=colormap[1:], edgecolor='none')
    ax3.set_xlim(0, params_agent.DURATION_MAX)
    ax3.set_ylim(-45, 45)
    ax3.set_xticklabels([])
    ax3.set_ylabel("mu (deg)")
    ax3.grid(True)

    ax4.scatter(timeVec[1:], (180 / np.pi) * np.array(ctrl_list)[:, 1], s=2, c=colormap[1:], edgecolor='none')
    ax4.set_xlim(0, params_agent.DURATION_MAX)
    ax4.set_ylim(0, 12)
    ax4.set_xlabel("time (s)")
    ax4.set_ylabel("alpha (deg)")
    ax4.grid(True)
    ax4.get_shared_x_axes().join(ax4, ax3)

    warnings.filterwarnings("ignore", category=UserWarning, module="backend_interagg")
    grid.tight_layout(fig, rect=[0, 0.03, 1, 0.95])
    plt.savefig("resultant_trajectory_episode_{}".format(n_iter) + ".png", dpi=400)
    plt.show()

    plt.close(fig)
    env.close()

if __name__ == '__main__':
    main()
