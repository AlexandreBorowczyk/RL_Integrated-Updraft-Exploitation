import datetime
import time
import os
import shutil
import gym
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.distributions import MultivariateNormal, Normal, Categorical
from torch.nn.utils.rnn import pack_padded_sequence, pad_packed_sequence, pad_sequence
import numpy as np
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader
from torch.utils.data import Dataset, TensorDataset

import evaluate_glider
from parameters import params_environment, params_triangle_soaring, params_decision_maker
from subtasks.updraft_exploiter import model_updraft_exploiter
from subtasks.vertex_tracker.waypoint_controller.waypoint_controller import Waypoint_Controller, Controller_Wrapper


device = torch.device("cuda:0")
# device = torch.device("cpu")

class Memory:
    def __init__(self):
        self.actions = []
        self.states = []
        self.next_states = []
        self.logprobs = []
        self.rewards = []
        self.done_masks = []

        self.lstm_h_in = []
        self.lstm_c_in = []
        self.lstm_h_out = []
        self.lstm_c_out = []

    def clear_memory(self):
        del self.actions[:]
        del self.states[:]
        del self.next_states[:]
        del self.logprobs[:]
        del self.rewards[:]
        del self.done_masks[:]

        del self.lstm_h_in[:]
        del self.lstm_c_in[:]
        del self.lstm_h_out[:]
        del self.lstm_c_out[:]

class ActorCritic(nn.Module):
    def __init__(self):
        super(ActorCritic, self).__init__()

        # instantiate parameters
        self._params_model = params_decision_maker.params_model()
        self._params_rl = params_decision_maker.params_rl()

        # set model elements: lstm net
        self.lstm           = nn.LSTM(input_size=self._params_model.DIM_IN, hidden_size=self._params_model.DIM_HIDDEN,
                                      batch_first=True)
        self.h_in          = torch.zeros(1, 1, self._params_model.DIM_HIDDEN)
        self.c_in          = torch.zeros(1, 1, self._params_model.DIM_HIDDEN)

        # set model elements: ffwd layers
        self.out_actor      = nn.Linear(self._params_model.DIM_HIDDEN, self._params_model.DIM_OUT)
        self.out_critic     = nn.Linear(self._params_model.DIM_HIDDEN, 1)

    def actor(self, observation, h_in=None, c_in=None):
        # initialize lstm
        h_in = self.h_in.to(device) if h_in is None else h_in
        c_in = self.c_in.to(device) if c_in is None else c_in

        # evaluate lstm
        _, (h_n, c_n) = self.lstm(observation, (h_in, c_in))

        # update lstm state (necessary for rollout, only)
        self.h_in = h_n
        self.c_in = c_n

        # forward lstm hidden state for t = seq_len
        x = torch.tanh(h_n[-1])

        # evaluate feedforward layer
        z = self.out_actor(x)

        # map output to [0, 1]
        p_exploit = 0.5*(torch.tanh(z) + 1)

        return p_exploit, (h_n, c_n)

    def critic(self, observation,  h_in=None, c_in=None):
        # initialize lstm
        h_in = self.h_in.to(device) if h_in is None else h_in
        c_in = self.c_in.to(device) if c_in is None else c_in

        # evaluate lstm
        _, (h_n, c_n) = self.lstm(observation, (h_in, c_in))

        # forward lstm hidden state for t = seq_len
        x = torch.tanh(h_n[-1])

        # evaluate feedforward layer
        state_value = self.out_critic(x)

        return state_value

    def act(self, state, memory, validation_mask):
        # store old lstm state
        if memory is not None:
            memory.lstm_h_in.append(self.h_in.to(device))
            memory.lstm_c_in.append(self.c_in.to(device))

        # evaluate current actor to sample action for rollout
        action_mean, lstm_state = self.actor(state)
        dist = Normal(action_mean, self._params_rl.SIGMA * (not validation_mask))
        action = dist.sample()
        action_logprob = dist.log_prob(action)

        # store state, action, logprob, lstm state (not for evaluate_glider())
        if memory is not None:
            memory.states.append(state)
            memory.actions.append(action)
            memory.logprobs.append(action_logprob)
            memory.lstm_h_out.append(lstm_state[0])
            memory.lstm_c_out.append(lstm_state[1])

        return action.detach()
    
    def evaluate(self, sampled_state, sampled_action, h_in, c_in):
        # evaluate actor for sampled states
        action_mean, _ = self.actor(sampled_state, h_in, c_in)
        dist = Normal(action_mean, self._params_rl.SIGMA)

        # get logprobs & entropy for distribution subject to current actor evaluated for sampled actions
        action_logprobs = dist.log_prob(sampled_action)
        # dist_entropy = dist.entropy()

        # evaluate critic for sampled states
        state_values = self.critic(sampled_state, h_in, c_in)

        return action_logprobs, state_values

    def reset_lstm(self, batchsize=1):
        self.h_in = torch.zeros(1, batchsize, self._params_model.DIM_HIDDEN)
        self.c_in = torch.zeros(1, batchsize, self._params_model.DIM_HIDDEN)

class PPO:
    def __init__(self, vertex_tracker, updraft_exploiter, environment):
        # instantiate parameters
        self._params_rl = params_decision_maker.params_rl()

        # instantiate actor-critic model
        self.policy = ActorCritic().to(device)
        # self.policy.load_state_dict(torch.load("decision_maker_actor_critic_final_15-April-2020_09-12.pt"))
        self.policy_old = ActorCritic().to(device)
        self.policy_old.load_state_dict(self.policy.state_dict())

        # setup optimizer
        self.optimizer = torch.optim.Adam(self.policy.parameters(),
                                          lr=self._params_rl.LEARNING_RATE, betas=(0.9, 0.999))
        self.MseLoss = nn.MSELoss()

        # instantiate vertex tracker and updraft exploiter
        self.vertex_tracker = vertex_tracker
        self.updraft_exploiter = updraft_exploiter
        self.env = environment
    
    def select_action(self, state, memory=None, validation_mask=False):
        # evaluate decision maker
        state = torch.FloatTensor(state.reshape(1, 1, -1)).to(device)  # batch=1 x sequence=1 x observations
        action_decision_maker = self.policy_old.act(state, memory, validation_mask).cpu().data.numpy().flatten()
        p_exploit = np.clip(action_decision_maker.item(), 0, 1)

        # evaluate vertex tracker
        action_vertex_tracker = self.vertex_tracker.select_action(self.env.get_full_observation)

        # evaluate updraft exploiter
        observation = torch.FloatTensor(self.env.get_rel_updraft_positions()).view(1, -1, 2).to(device)
        action_updraft_exploiter = self.updraft_exploiter.act(observation, None, True).cpu().data.numpy().flatten()

        # mix the actions
        action = p_exploit*action_updraft_exploiter + (1-p_exploit)*action_vertex_tracker

        return action
    
    def update(self, memory):
        # convert list to tensor
        actions     = torch.squeeze(torch.stack(memory.actions), 1).detach()
        states      = torch.squeeze(torch.stack(memory.states), 1).detach()
        next_states = torch.squeeze(torch.stack(memory.next_states), 1).detach()
        logprobs    = torch.squeeze(torch.stack(memory.logprobs), 1).detach()
        rewards     = torch.stack(memory.rewards).detach()
        done_masks  = torch.stack(memory.done_masks).detach()
        lstm_h_in   = torch.squeeze(torch.stack(memory.lstm_h_in), 1).detach()
        lstm_c_in   = torch.squeeze(torch.stack(memory.lstm_c_in), 1).detach()
        lstm_h_out  = torch.squeeze(torch.stack(memory.lstm_h_out), 1).detach()
        lstm_c_out  = torch.squeeze(torch.stack(memory.lstm_c_out), 1).detach()

        # Generalized-Advantage-Estimation (GAE)
        v_prime = self.policy_old.critic(next_states, lstm_h_out.permute(1, 0, 2), lstm_c_out.permute(1, 0, 2))
        td_targets = rewards + self._params_rl.GAMMA * v_prime * done_masks
        v_s = self.policy_old.critic(states, lstm_h_in.permute(1, 0, 2), lstm_c_in.permute(1, 0, 2))
        deltas = td_targets - v_s
        deltas = deltas.detach().cpu().numpy()

        advantage_lst = []
        advantage = 0.0
        for item in deltas[::-1]:
            advantage = self._params_rl.GAMMA * self._params_rl.LAMBDA * advantage + item[0]
            advantage_lst.append([advantage])
        advantage_lst.reverse()
        advantages = torch.tensor(advantage_lst, dtype=torch.float).to(device)

        # put batch to data_loader
        train_loader = DataLoader(dataset=TensorDataset(actions, states, logprobs, lstm_h_in, lstm_c_in,
                                                        advantages, td_targets),
                                  batch_size=self._params_rl.MINIBATCHSIZE, shuffle=True)

        # Optimize policy for K epochs:
        for _ in range(self._params_rl.K_EPOCH):
            for mini_batch in train_loader:
                # get sampled data in mini-batch and send them to device
                actions, states, logprobs, lstm_h_in, lstm_c_in, advantages, td_targets = mini_batch

                # evaluate policy for sampled states and actions
                logprobs_eval, state_vlaues_eval = self.policy.evaluate(states, actions,
                                                                        lstm_h_in.permute(1, 0, 2),
                                                                        lstm_c_in.permute(1, 0, 2))

                # ppo ratio
                ratios = torch.exp(logprobs_eval - logprobs)

                # surrogate loss
                surr1 = ratios * advantages
                surr2 = torch.clamp(ratios, 1 - self._params_rl.EPS_CLIP, 1 + self._params_rl.EPS_CLIP) * advantages
                loss = -torch.min(surr1, surr2).mean() + 0.5*self.MseLoss(state_vlaues_eval, td_targets.detach())

                # gradient step
                self.optimizer.zero_grad()
                loss.mean().backward()
                self.optimizer.step()

        # transfer weights
        self.policy_old.load_state_dict(self.policy.state_dict())


def main():
    # set up training
    tstart = time.time()
    env = gym.make('glider3D-v0', agent='decision_maker')

    # instantiate vertex tracker and updraft exploiter
    waypoint_controller = Controller_Wrapper(env)
    updraft_exploiter = model_updraft_exploiter.ActorCritic().to(device)
    updraft_exploiter.load_state_dict(torch.load("updraft_exploiter_actor_critic_final_08-April-2020_20-46.pt"))

    # instantiate agent
    ppo = PPO(waypoint_controller, updraft_exploiter, env)
    memory = Memory()

    # load parameters
    _params_rl = params_decision_maker.params_rl()
    _params_agent = params_decision_maker.params_agent()
    _params_logging = params_decision_maker.params_logging()
    
    # create folder to store data for the experiment running
    experimentID = 1
    dirName = "{}_decision_maker_experiment_running".format(experimentID)
    while os.path.exists(dirName):
        experimentID += 1
        dirName = "{}_".format(experimentID) + dirName.split('_', 1)[1]
    os.mkdir(dirName)
    shutil.copytree(os.getcwd(), os.path.join(dirName, "Sources_unzipped"),
                    ignore=shutil.ignore_patterns('*experiment*', 'archive', 'tests', '.git*', 'rl_ccs_experiments',
                                                  '.idea', '__pycache__', 'README*'))
    os.chdir(dirName)
    shutil.make_archive("Sources", 'zip', "Sources_unzipped")
    shutil.rmtree("Sources_unzipped")
    print("Directory for running experiment no. {} created".format(experimentID))

    # save parameters to file
    parameterFile = open("parameterFile.txt", "w")
    parameterFile.write(
        format(vars(_params_rl)) + "\n" +
        format(vars(params_decision_maker.params_model())) + "\n" +
        format(vars(_params_agent)) + "\n" +
        format(vars(_params_logging)) + "\n\n" +
        format(vars(params_triangle_soaring.params_task())) + "\n\n" +
        format(vars(params_environment.params_sim())) + "\n" +
        format(vars(params_environment.params_glider())) + "\n" +
        format(vars(params_environment.params_physics())) + "\n" +
        format(vars(params_environment.params_wind())))
    parameterFile.close()

    # set random seed
    if _params_rl.SEED:
        print("Random Seed: {}".format(_params_rl.SEED))
        torch.manual_seed(_params_rl.SEED)
        env.seed(_params_rl.SEED)
        np.random.seed(_params_rl.SEED)

    # set up file to save average returns
    returnFile = open("returnFile_running.dat", "w")
    returnFile.write("episodes, policy iterations, avg. return over {} episodes\n"
                     .format(_params_logging.PRINT_INTERVAL))
    returnFile.close()

    # initialize logging variables
    returns = []
    average_returns = []
    policy_iterations = 0
    timestep_counter = 0

    # showcase behavior before training takes place
    evaluate_glider.main(env, ppo, 0, _params_agent, validation_mask=False)
    
    # training loop
    for n_epi in range(1, int(_params_rl.N_EPISODES + 1)):
        env.reset()
        ppo.policy.reset_lstm()
        done = False
        ret = 0
        observation = env.get_observation()

        while not done:
            timestep_counter += 1

            # run policy
            action = ppo.select_action(observation, memory)
            observation, reward, done, _ = env.step(action)
            ret += reward

            # store s_prime, reward, and done mask:
            memory.next_states.append(torch.FloatTensor(observation.reshape(1, 1, -1)).to(device))
            memory.rewards.append(torch.FloatTensor([reward]).to(device))
            memory.done_masks.append(torch.FloatTensor([not done]).to(device))

            # update policy every BATCHSIZE timesteps
            if timestep_counter % _params_rl.BATCHSIZE == 0:
                ppo.policy.train()
                ppo.update(memory)
                ppo.policy.eval()
                memory.clear_memory()
                timestep_counter = 0
                policy_iterations += 1

            # stop rollout if episode is completed
            if done:
                returns.append(ret)
                break

        n_mean = _params_logging.PRINT_INTERVAL if len(returns) >= _params_logging.PRINT_INTERVAL else len(returns)
        average_returns.append(np.convolve(returns[-n_mean:], np.ones((n_mean,)) / n_mean, mode='valid')[0])

        if n_epi % _params_logging.PRINT_INTERVAL == 0:
            print("# episode: {}/{} \t\t vertices hit: {} \t avg return over last {} episodes: {:.1f}"
                  .format(n_epi, int(_params_rl.N_EPISODES),  (env.lap_counter * 3 + env.vertex_counter),
                          _params_logging.PRINT_INTERVAL, average_returns[-1]))

            with open("returnFile_running.dat", "a+") as returnFile:
                returnFile.write(format(n_epi) + "," + format(policy_iterations) + ","
                                 + '{:.1f}'.format(average_returns[-1]) + "\n")

        if n_epi % _params_logging.SAVE_INTERVAL == 0:
            torch.save(ppo.policy.state_dict(), "decision_maker_actor_critic_episode_{}".format(n_epi) + ".pt")
            evaluate_glider.main(env, ppo, n_epi, _params_agent, validation_mask=False)

    # display results
    print('Duration: %.2f s' % (time.time() - tstart))
    evaluate_glider.main(env, ppo, n_epi, _params_agent, validation_mask=True)
    now = datetime.datetime.now()
    plt.figure("average returns")
    plt.plot(average_returns)
    plt.ylabel("average returns (-)")
    plt.xlabel("episodes (-)")
    plt.grid(True)
    plt.savefig("average_returns_" + now.strftime("%d-%B-%Y_%H-%M") + ".png")
    plt.show()

    # save actor-critic
    torch.save(ppo.policy.state_dict(), "decision_maker_actor_critic_final_" + now.strftime("%d-%B-%Y_%H-%M") + ".pt")

    # rename parameter file consistently
    os.rename(parameterFile.name, "parameters_" + now.strftime("%d-%B-%Y_%H-%M") + ".txt")

    # rename return file consistently
    returnFile.close()
    os.rename(returnFile.name, "average_returns_" + now.strftime("%d-%B-%Y_%H-%M") + ".dat")

    env.close()


if __name__ == '__main__':
    main()